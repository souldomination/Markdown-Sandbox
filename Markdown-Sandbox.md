# 습격자 초라기와 쿼리 (Easy)

이 문제는 습격자 초라기에 쿼리를 섞으면 어떻게 될까 하는 마음에 만들어본 문제입니다.
그런데 진짜 습격자 초라기에 쿼리까지 추가해버리면 너무 어렵기 때문에 원이 두 개가 아닌 하나만 있는 Easy 버전을 출제했읍니다.

쿼리가 없는 경우를 원래 DP로 O(n)에 풀 수 있는 문제지만 분할 정복으로 O(nlogn)에도 풀 수 있다 것이 이 문제에 핵심 아이디어입니다.
일단 원이 아니라 직선으로 펼쳐놓은 문제를 생각해봅시다. 구역 a부터 b까지를 커버하는 데 필요한 특수 소대에 최소 갯수를 f(a, b)라 하면 f(1, n)에 값은

* f(1, n/2) + f(n/2+1, n)
* 만약 구역 n/2과 n/2+1에 배치된 적에 수에 합이 w보다 작으면, f(1, n/2-1) + f(n/2+2, n)

중 최소값입니다. 그런데 점화식에서 함수 f를 재귀적으로 4번 부르죠. 마스터 정리를 쓰면 시간 복잡도가 O(n^2)입니다.
이걸 해결하기 위해 함수을(를) 4개 정의합니다.

* f1(a, b): a부터 b까지 커버하는 데 필요한 최소값
* f2(a, b): a+1부터 b까지 커버하는 데 필요한 최소값
* f3(a, b): a부터 b-1까지 커버하는 데 필요한 최소값
* f4(a, b): a+1부터 b-1까지 커버하는 데 필요한 최소값

이렇게 정의된 함수들의 점화 관계를 세우면 O(nlogn)으로 해결할 수 있읍니다.
(물론 분할 과정에서 중복으로 호출되는 함수들은 메모리제이션을 꼭 하도록 합시다.)
함수를 4개 정의하면 생기는 또 다른 장점은, f4(1, n)에 값을 계산하면 직선으로 펼친 문제 뿐만 아니라 원래의 원형에서도 최소값을 구할 수 있다는 겁니다.

커리는 f1, f2, f3, f4를 저장하는 세그먼트 트리를 만들어서 해결하면 됩니다.
초기화에 O(nlogn)이 걸리고 업데이트 밑 쿼리 답변에 O(logn)이 걸림으로 최종 시간 복잡도는 O((n+q)logn)입니다.

전체적인 풀이는 16993번 연속합과 쿼리 문제와 비슷합니다.
